# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Shuveb Hussain
# This file is distributed under the same license as the Lord of the
# io_uring package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Lord of the io_uring \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-24 23:08+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../tutorial/webserver_liburing.rst:4
msgid "A web server with liburing"
msgstr "使用 liburing 的 web 服务器"

#: ../../tutorial/webserver_liburing.rst:6
msgid ""
"We discussed in :ref:`the introduction <async_intro>` that because "
":man:`select(2)`, :man:`poll(2)` and :man:`epoll(7)` report operations on"
" local / regular files as always being in a ready state, libraries like "
"libuv (this one powers NodeJS) use a separate thread pool to deal with "
"file I/O. One huge advantage with ``io_uring`` is that it presents a "
"single, clean uniform and above all, efficient interface for many types "
"of I/O."
msgstr ""

#: ../../tutorial/webserver_liburing.rst:8
msgid ""
"In this example, we’ll look at an additional operation, ``accept()`` and "
"how to do it using ``io_uring``. Throw in operations for ``readv()`` and "
"``writev()``, you have the capability to write a simple web server! This "
"web server is based on code I wrote for ZeroHTTPd, a program that "
"features in an `article series <https://unixism.net/2019/04/linux-"
"applications-performance-introduction/>`_ I wrote to explore various "
"Linux process models and how they perform compared to each other. I’ve "
"rewritten ZeroHTTPd to use the ``io_uring`` interface exclusively."
msgstr ""

#: ../../tutorial/webserver_liburing.rst:10
msgid "Here is the index page served via ZeroHTTPd:"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:16
msgid "Let’s jump into the code now."
msgstr "让我们直接看代码"

#: ../../tutorial/webserver_liburing.rst:469
msgid "Running this program"
msgstr "运行这个程序"

#: ../../tutorial/webserver_liburing.rst:470
msgid ""
"This program requires that you run it from the directory that contains "
"the \"public\" folder that has an ``index.html`` file and an image to go "
"with it. If you followed the `build instructions "
"<https://github.com/shuveb/loti-examples>`_ to the example programs, your"
" newly built binary should be in the ``build`` directory. You need to "
"change into the git repo's root directory where the \"public\" folder "
"resides and run it. An sample session where you build all examples and "
"run the this webserver example would look like this:"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:485
msgid "Program structure"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:486
msgid ""
"Before anything else, the ``main()`` function calls "
"``setup_listening_socket()`` to listen on the designated port. But we do "
"not call ``accept()`` to actually accept connections. We do that through "
"a request to ``io_uring`` as explained later."
msgstr ""

#: ../../tutorial/webserver_liburing.rst:488
msgid ""
"The core of the program is the ``server_loop()`` function, which issues "
"submissions (itself and via other functions) to ``io_uring``, waits for "
"completion queue entries and processes them. Let’s take a closer look at "
"it."
msgstr ""

#: ../../tutorial/webserver_liburing.rst:535
msgid ""
"Right before we enter the ``while`` loop, we submit a request for "
"``accept()`` with a call to ``add_accept_request()``. This allows any "
"client connection to the server to be accepted. Let’s take a closer look "
"at that."
msgstr ""

#: ../../tutorial/webserver_liburing.rst:551
msgid ""
"We get an SQE, and prepare an ``accept()`` operation to be submitted with"
" :c:func:`io_uring_prep_accept` from ``liburing``. We use a ``struct "
"request`` to track each of our submissions. These instances have the "
"context of each request as it goes from one state to the next. Let’s take"
" a look at struct request:"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:562
msgid ""
"There are 3 state that a client request goes through and the structure "
"above can hold enough information to be able to handle transitions "
"between these states. The three states of a client request are:"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:564
msgid "Accepted -> Request read -> Response written"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:566
msgid ""
"Let’s take a look at what happens once an ``accept()`` operation "
"completes in the large switch/case block on the completion side:"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:576
msgid ""
"We add a new ``accept()`` request back in the submission queue now that "
"we’ve processed the previous one. Else our program won’t be accepting any"
" new connections from clients. We then call the ``add_read_request()`` "
"function which adds a submission request for ``readv()`` so that we can "
"read the HTTP request from the client. Couple of things here: We could "
"have used ``read()``, but that operation isn’t supported in ``io_uring`` "
"until kernel version 5.6, which, as of the time of this writing, is the "
"bleeding edge stable version and won’t be found in many distributions for"
" several months at least. Also, using ``readv()`` and ``writev()`` allows"
" us to build in a lot of common logic, especially around buffer "
"management as we’ll see later. Now, let’s look at ``add_read_request()``:"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:595
msgid ""
"As you can see, this is pretty straight-forward. We allocate a buffer "
"large enough to hold the client request and issue a call to "
":c:func:`io_uring_prep_readv` which is in liburing before we submit the "
"request. The corresponding handling on the completion side is done by the"
" condition in the switch/case block:"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:609
msgid ""
"Here, essentially we call the ``handle_client_request()`` function which "
"deals with handling the HTTP request. If all goes well and it is a file "
"on disk that the client is asking for, this is the piece of code that "
"runs:"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:621
msgid ""
"The ``set_headers()`` function sets up a total of 5 small buffers "
"represented by 5 different ``struct iovec`` structures. The final iovec "
"instance contains the contents of the file being read. Finally, "
"``add_write_request()`` is called which adds a submissions queue entry:"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:634
msgid ""
"This submission causes the kernel to write out the response headers and "
"the contents of the file over the client socket, thus completing the "
"request/response cycle. Here is what we do on the completion side:"
msgstr ""

#: ../../tutorial/webserver_liburing.rst:646
msgid ""
"We free up how many ever ``iovec`` pointed buffers we created, free up "
"the request structure instance and also close the client socket, thus "
"completing serving of the HTTP request."
msgstr ""

#: ../../tutorial/webserver_liburing.rst:649
msgid "Source code"
msgstr "源码"

#: ../../tutorial/webserver_liburing.rst:650
msgid ""
"Source code for this and other examples is `available on Github "
"<https://github.com/shuveb/loti-examples>`_."
msgstr ""

